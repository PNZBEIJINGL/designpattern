
一些学习随手敲的代码
------------------------------------------------------
一些是书中的demo
一些是看到的不错的设计方法
一些是自己用过的
------------------------------------------------------
《Head Fist 设计模式》
 * 抽象 封装 多态 继承
 *
 * 设计原则
 * 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混合在一起
 * 封装变化
 * 多用组合少用继承
 * 最少知识原则告诉我们要减少对象之间的交互，只和你的密友谈话
 *
 * 依赖倒置： 针对接口编程而不是针对实现
 * 开闭原则： 对扩展开放，对修改关闭
 * 单一指责： 类应该只有1个理由可以使其改变
 * 接口隔离： 建立单一接口，不要建立臃肿庞大的接口。即接口尽量细化，同时接口中的方法尽量少
------------------------------------------------------
《Java 多线程设计模式图解》
start()方法可以用来启动线程；该方法会在内部调用Runnable接口的run()方法，以在单独的线程中执行run()方法中指定的代码。
start()方法启动线程执行以下任务：
1）它统计了一个新线程
2）线程从New State移动到Runnable状态。
3）当线程有机会执行时，它的目标run()方法将运行。
run()方法是Runnable接口的一个抽象方法，由java虚拟机直接调用的，不会创建的新线程

------------------------------------------------------
《Java 多线程编程核心技术》

20190810：基础很重要，还是要补基础知识
synchronized:
1）拥有锁重入的狗功能，当一个线程得到一个对象锁后，再次请求此对象时可以再次得到该对象的锁
2）出现异常锁自动释放
3）同步不能被继承，父类方法加锁后，子类方法重写也需要加锁 ！ 跳坑！！
4）用关键字synchronized声明方法在某些情况下是有弊端的，比如A线程调用同步方法执行一个长时间的任务，那么
   B线程则必须等待比较长时间，这种情况下可以使用synchronized(this)同步语句块来解决的。synchronized方法是对当前
   对象加锁，而synchronized代码块是对某一个对象加锁
5）使用同步代码块synchronized(this)时，当访问一个对象的synchroized(this)同步代码块时，其他线程访问同一个Object
   中所有其他synchronized(this)同步代码块的访问将会被阻塞，说明synchronized(this)使用的对象监听器是同一个
   synchronized同步方法
   （1）对其他synchronized同步方法或者synchronized（this）同步代码块调用呈现阻塞状态
   （2）同一个时间只有1个线程可以访问执行synchronized同步方法里的代码
   synchronized（this）
   （1）对其他synchronized同步方法或者synchronized（this）同步代码块调用呈现阻塞状态
   （2）同一个时间只有1个线程可以访问执行synchronized（this）代码块中的代码
   synchronized（非this）
   （1）在多个线程持有对象监听器为同一个对象的前提下，同一个时间只有一个线程可以执行synchronized(非this对象)同步代码块的代码
   （2）当持有对象监视器为同一个对象的前提下，同一时间只有一个线程可以执行
   synchronized static同步静态方法
   （1）同步静态方法时锁class类
   synchronized（class）同步class代码块的作用和synchronized static作用一样

volatile:
1)volatile主要作用是使变量在多个线程间可见
2)volatile非原子性


wait()     方法可以使调用该方法的线程释放共享资源的锁,然后从运行状态退出并进入等待队列，等待被再次唤醒
notify()   方法可以随机唤醒等待队列中等待同一共享资源的一个线程，并使该线程退出等待队列,进入可运行状态，也就是notify()方法仅通知1个线程
notifyAll()方法可以使所有正在等待队列中等待同一共享资源的全部线程从等待状态退出，进入可运行状态，优先级最高的那个线程最先执行，



1）新创建一个新的线程对象后，再调用start()方法，系统会为此线程分配CPU资源，使其处于Runable状态，这是一个准备运行的阶段
。如果线程抢占到CPU资源，这个线程就处于Running状态
2）Runnable状态和Running状态可相互切换，因为有可能线程运行一段时间后，有其他高优先级线程抢占CPU资源，这时此线程就从
Running 状态变成Runnable状态

join() 的作用是等待线程对象销毁
join 和 synchronized 的区别是join 在内部使用, synchronized 关键字使用的是对象监视器原理同步
joint(long) 设置等待时间


Lock.
lock.lock()就有了对象监听器，其他线程就需要等待，锁被释放的时候再被争夺，就和　synchronized关键字一样
线程间执行的顺序是随机的

公平锁：表示线程获取锁的顺序是按照线程枷锁的顺序来分配的，即先来先得的FIFO先进先出的顺序
非公平锁：就是一种获取锁的抢占机制，获取锁是随机的，这可能造成线程一直拿不到锁，结果也是不公平的

Timer
Timer类的主要作用是设计和计划任务,TimerTask类封装任务.TimerTask是一个抽象类
Timer类中允许有多个TimerTask 任务，是以队列（TaskQueue）的方式一个一个被顺序执行